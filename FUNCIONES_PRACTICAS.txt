/*!
    @brief Calcular el valor medio de una imagen y su varianza.
        
    Esta es la forma más intuitiva de recorrer una imagen.
    
    @param[in] img es la imagen de entrada.
    @param[out] media la media de los valores.
    @param[out] dev la desviación estárdar de los valores.
    
    @pre img no está vacia.
    @pre img es de tipo CV_8UC1 (Un sólo canal en formato byte).
*/    
void 
compute_stats1(const cv::Mat& img, float& media, float& dev)
{
    //Comprobacion de precondiciones.
    CV_Assert( !img.empty() );
    CV_Assert( img.type() == CV_8UC1 );
   
    media = 0.0;
    dev = 0.0;
    
    //Para cada fila 0 ... img.rows-1
    for (int row=0; row<img.rows; ++row)
        //Para cada columna 0 ... img.cols-1
        for (int col=0; col<img.cols; ++col)
        {
            //Acceder a un pixel con el metodo at<Tipo de pixel>(fila, columna).
            //Aqui cada pixel es un byte (uchar).

            const float v = img.at<uchar>(row, col);

            //También podríamos tener otros tipos:
            //   Tres bytes por pixel (CV_8UC3) ->  at<cv::Vec3b>
            //   Un solo float por pixel (CV_32FC1)  ->  at<float>
            //   tres floats por pixel (CV_32FC3)   -> at<cv::Vec3f>
            //   ... más combinaciones.


            media += v;
            dev += v*v;
        }

    const float count = img.rows*img.cols;
    
    media /= count;
    dev /= count;
    dev = cv::sqrt(dev - media*media);
}

/*!
    @brief Calcular el valor medio de una imagen y su varianza.

    Esta forma usa iteradores, más fácil de codificar cuando sólo queremos
    procesar todos los pixeles uno a uno.

    @param[in] img es la imagen de entrada.
    @param[out] media la media de los valores.
    @param[out] dev la desviación estárdar de los valores.

    @pre img no está vacia.
    @pre img es de tipo CV_8UC1 (Un sólo canal en formato byte).
*/
void
compute_stats2(const cv::Mat& img, float& media, float& dev)
{
    //Comprobacion de precondiciones.
    CV_Assert( !img.empty() );
    CV_Assert( img.type() == CV_8UC1 );

    media = 0.0;
    dev = 0.0;

    const auto end = img.end<uchar>();
    for (auto p = img.begin<uchar>(); p != end; ++p )
    {
        //También podríamos tener otros tipos:
        //   Tres bytes por pixel (CV_8UC3) ->  begin<cv::Vec3b>()
        //   Un solo float por pixel (CV_32FC1)  ->  begin<float>()
        //   tres floats por pixel (CV_32FC3)   -> begin<cv::Vec3f>()
        //   ... mas combinaciones.

        const float v = *p;
        media += v;
        dev += v*v;
    }

    const float count = img.rows*img.cols;

    media /= count;
    dev /= count;
    dev = cv::sqrt(dev - media*media);
}

/*!
    @brief Calcular el valor medio de una imagen y su varianza.

    Esta forma usa código vectorizado (funciones SIMD). Utilizamos funciones
    de opencv que permiten vectorizar el código.

    @param[in] img es la imagen de entrada.
    @param[out] media la media de los valores.
    @param[out] dev la desviación estárdar de los valores.

    @pre img no está vacia.
    @pre img es de tipo CV_32FC1 (Un sólo canal en formato float).
*/
void
compute_stats3(const cv::Mat& img, float& media, float& dev)
{
    //Comprobacion de precondiciones.
    CV_Assert( !img.empty() );
    CV_Assert( img.depth() == CV_32FC1 );

    media = static_cast<float>(cv::sum(img)[0]);
    dev = static_cast<float>(cv::sum(img.mul(img))[0]);

    const float count = img.rows*img.cols;

    media /= count;
    dev /= count;
    dev = cv::sqrt(dev - media*media);
}

/*!
    @brief Calcular el valor medio de una imagen y su varianza.

    Esta forma usa una función de opencv (no siempre hay una!!).

    @param[in] img es la imagen de entrada.
    @param[out] media la media de los valores.
    @param[out] dev la desviación estárdar de los valores.

    @pre img no está vacia.
    @pre img es de tipo CV_32FC1 (Un sólo canal en formato float).
*/
void
compute_stats4(const cv::Mat& img, float& media, float& dev)
{
    //Comprobacion de precondiciones.
    CV_Assert( !img.empty() );
    CV_Assert( img.type() == CV_32FC1 );

    cv::Scalar mean;
    cv::Scalar stdev;
    cv::meanStdDev(img, mean, stdev);
    media = static_cast<float>(mean[0]);
    dev = static_cast<float>(stdev[0]);
}

#######################################################################################################

MOSTRAR UNA IMAGEN

	cv::namedWindow("IMG", cv::WINDOW_GUI_EXPANDED); // Creamos la ventana grafica para mostrar la imagen
	cv::imshow("IMG", img); //Visualizo la imagen cargada en la ventana.
	std::cout << "Pulsa ESC para salir." << std::endl;
	gwhile ((cv::waitKey(0) & 0xff) != 27); //Hasta que no se pulse la tecla ESC no salimos.

#######################################################################################################
CARGAR UN VIDEO Y VISUALIZARLO

/**
* @brief Función callback para gestión del ratón.
* @param event Qué ocurrió.
* @param x coordenada x del cursor del ratón.
* @param y coordenada y del cursor del ratón.
* @param flags estado del teclado.
* @param userdata datos que el usuario ha pasado al crear el callback.
*/
void on_mouse(int event, int x, int y, int flags, void *userdata)
{
    if (event == cv::EVENT_LBUTTONDOWN)
    {
        static_cast<int*>(userdata)[0] = x;
        static_cast<int*>(userdata)[1] = y;
    }
}

void CallBackFunc(int event, int x, int y, int flags, void* userdata)
{
	if ( event == cv::EVENT_LBUTTONDOWN ) std::cout << "Left button of the mouse is clicked - position (" << x << ", " << y << ")" << std::endl;
     	else if  ( event == cv::EVENT_RBUTTONDOWN ) std::cout << "Right button of the mouse is clicked - position (" << x << ", " << y << ")" << std::endl;
     	else if  ( event == cv::EVENT_MBUTTONDOWN ) std::cout << "Middle button of the mouse is clicked - position (" << x << ", " << y << ")" << std::endl;
}

int wait = parser.get<int>("w");      
int camera_idx = parser.get<int>("camera");
std::string video_name = parser.get<std::string>("video");
cv::VideoCapture vid; // Captura del video
if (parser.has("video")) vid.open(video_name); // Abrimos el video
else vid.open(camera_idx); // Abrimos un dispositivo usando indices enteros ( para identificarlo, usamos -1 para abrir el primero disponible      
if (!vid.isOpened())
{
	std::cerr << "Error: no he podido abrir el la fuente de vídeo." << std::endl;
        return EXIT_FAILURE;
}
cv::namedWindow("VIDEO"); // Ventana grafica para el video
cv::Mat frame;
vid >> frame; //Captura el primer frame.
if (frame.empty())
{
	std::cerr << "Error: could not capture any frame from source." << std::endl;
        return EXIT_FAILURE;
}
std::cout << "Input size (WxH): " << frame.cols << 'x' << frame.rows << std::endl;
std::cout << "Frame rate (fps): " << vid.get(cv::CAP_PROP_FPS) << std::endl;
std::cout << "Num of frames   : " << vid.get(cv::CAP_PROP_FRAME_COUNT) << std::endl;
int coords[2] = {frame.cols/2, frame.rows/2}; //Coordenadas del pixel a muestrear. Inicialmente mostramos el pixel central.
cv::setMouseCallback ("VIDEO", on_mouse, coords); // Gestion del raton
std::cerr << "Pulsa una tecla para continuar (ESC para salir)." << std::endl;
int key = cv::waitKey(0) & 0xff;
while (!frame.empty() && key!=27)
{
	cv::imshow("VIDEO", frame); //muestro el frame.
        const cv::Vec3b v = frame.at<cv::Vec3b>(coords[1], coords[0]); //mostramos los valores RGB del pixel muestreado.
        std::cout << "RGB point (" << coords[0] << ',' << coords[1] << "): "
                  << static_cast<int>(v[0]) << ", "
                  << static_cast<int>(v[1]) << ", "
                  << static_cast<int>(v[2]) << std::endl;
         key = cv::waitKey(wait) & 0xff; //Espero un tiempo fijado. Si el usuario pulsa una tecla obtengo el codigo ascci. Si pasa el tiempo, retorna -1.
         vid >> frame; //capturo el siguiente frame.
}
#########################################################################################################
FUNCIONES DE COLOR

cvtColor(img, out, cv::COLOR_GRAY2RGB); // CONVERTIR UNA IMAGEN DE GRISES A COLOR RGB
cvtColor(img, out, cv::COLOR_RGB2GRAY); // CONVERTIR UNA IMAGEN DE COLOR RGB A GRISES
cv::cvtColor(img,out, cv::COLOR_BGR2HSV); // CONVERTIR BGR A HSV
cv::cvtColor(img,out,cv::COLOR_HSV2BGR); // CONVERTIR HSV A BGR
#########################################################################################################

GENERAR FIGURAS POLINOMICAS

1. GENERAR UNA MASCARA EN FORMA DE RECTANGULO
	cv::Point ptr1(x,y); // Obtenemos las coordenadas de los vertices
	cv::Point ptr2(x+rect_width, x+rect_height); // Obtenemos las lineas que unen los vertices del rectangulo
	cv::rectangle(mask,ptr1,ptr2,cv::Scalar(255,255,255), cv::FILLED); // Creamos el rectangulo
2. GENERAR UNA MASCARA EN FORMA DE CIRCULO
	cv::Point centro(x,y);// Obtenemos el punto centro del circulo
	cv::circle(mask,centro,radius,cv::Scalar(255,255,255), cv::FILLED); // Generamos el circulo
3. GENERAR UNA MASCARA EN FORMA DE POLIGONO
	cv::fillPoly(mask,points,cv::Scalar(255,255,255)); // Rellenamos el poligono
##########################################################################################################
COMBINAR IMAGENES
    cv::Mat mascaraAND1, mascaraAND2, mascaraNegada1; // Creamos las mascaras de union
    cv::bitwise_and(foreground,mask,mascaraAND1);
    cv::bitwise_not(mask,mascaraNegada1); // Negamos la mascara de la imagen foregorund
    cv::bitwise_and(background,mascaraNegada1,mascaraAND2);
    cv::bitwise_or(mascaraAND1,mascaraAND2,output);
###########################################################################################################
FUNCIONES DE IMAGEN

	cv::Mat img = cv::imread(img1, cv::IMREAD_ANYCOLOR); // Cargamos la imagen desde un archivo
	// cv::Mat img = cv::imread(img_name, cv::IMREAD_GRAYSCALE);
	// cv::Mat img = cv::imread(img_name, cv::IMREAD_COLOR);
	mask = cv::Mat::zeros(img_height,img_width,type); // Rellenar una imagen de ceros
	cv::Mat in = cv::imread(input_n, cv::IMREAD_UNCHANGED); // Leer la imagen de entrada
	if (img.empty()) // Imagen no cargada
	std::vector<cv::Mat> canales; // Crear un vector de canales
	cv::split(img, canales);	//Guardamos cada canal como una matriz diferente. Lo enlazamos con la imagen1
	for(size_t i=0; i < canales.size(); i++) // Recorremos cada canal de la imagen
        cv::minMaxIdx(canales[i],&min,&max); 	// Obtencion de los valores minimo y maximo del canal i
	cv::Mat mask = in.clone(); // Clonar una imagen
	cv::imshow("INPUT", in); // Mostrar una imagen en una ventana grafica
	if(parser.get<std::string>("r")!="x,y,w,h") // Obtencion de los valores asignados a un parametro "r"
	std::istringstream buffer(parser.get<std::string>("r")); // Almacenamiento de los valores de un parametro en el buffer
	buffer>>x>>sep>>y>>sep>>width>>sep>>height; // Asignacion de los valores del buffer
	if(!buffer) // Buffer vacio
	std::vector<cv::Point> puntos; // Vector de puntos
	img.convertTo(out,CV_32F, 1.0/255.0); // Convertir byte a float
	img.convertTo(out,CV_8U,255.0); // Convertir float a byte